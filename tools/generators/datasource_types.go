package main

import (
	"fmt"
	"go/ast"
	"go/types"
	"golang.org/x/tools/go/packages"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

func main() {
	goPackage := os.Getenv("PWD")

	fmt.Println(goPackage)

	pkg, err := LoadPkg(goPackage)

	dataPoints, workers := ExtractDataPointsAndWorkers(pkg)

	templateParams := map[string]string{
		"Workers":    ListStruct("WorkerTypes", workers),
		"DataPoints": ListStruct("DataSourceTypes", dataPoints),
	}

	genPath := filepath.Join(goPackage, "generated_types.go")

	file, err := os.OpenFile(genPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		log.Panic(err)
		return
	}
	defer file.Close()

	t := template.Must(template.New("teste").Parse(queueTemplate))
	err = t.Execute(file, templateParams)
	if err != nil {
		log.Panic(err)
	}
}

var queueTemplate = `// Package datasources Code generated by generator, DO NOT EDIT.
package datasources

{{.Workers}}
{{.DataPoints}}
`

func LoadPkg(goPackage string) (*packages.Package, error) {

	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedSyntax | packages.NeedImports}
	pkgs, err := packages.Load(cfg, goPackage)
	if err != nil {
		return nil, err
	}

	pkg := pkgs[0]

	if pkg.Errors != nil {
		return nil, pkg.Errors[0]
	}

	return pkg, nil
}

func ExtractDataPointsAndWorkers(pkg *packages.Package) (map[string]*types.Struct, map[string]*types.Struct) {
	dataPoints := make(map[string]*types.Struct, 0)
	workers := make(map[string]*types.Struct, 0)

	for _, syntax := range pkg.Syntax {
		ast.Inspect(syntax, func(x ast.Node) bool {
			s, ok := x.(*ast.TypeSpec)
			if !ok {
				return true
			}

			if strings.HasSuffix(s.Name.Name, "DataPoint") {
				obj := pkg.Types.Scope().Lookup(s.Name.Name)

				if structType, ok := obj.(*types.TypeName).Type().Underlying().(*types.Struct); ok {
					dataPoints[strings.TrimSuffix(s.Name.Name, "DataPoint")] = structType
				}

				return true
			}

			if strings.HasSuffix(s.Name.Name, "Worker") {

				obj := pkg.Types.Scope().Lookup(s.Name.Name)

				if structType, ok := obj.(*types.TypeName).Type().Underlying().(*types.Struct); ok {
					workers[strings.TrimSuffix(s.Name.Name, "Worker")] = structType
				}

				return true
			}
			return false
		})
	}

	return dataPoints, workers
}

func ListStruct(prefix string, workers map[string]*types.Struct) string {
	names := fmt.Sprintf("var %s = []string{\n", prefix)

	for k, _ := range workers {
		names += fmt.Sprintf("\t\"%s\",\n", k)
	}

	names += "}\n"
	return names
}
